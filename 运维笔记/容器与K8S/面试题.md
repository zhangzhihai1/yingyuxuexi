# 1.pod调度流程

面试中被问到 **「Pod 的调度流程」**，你可以从 **整体流程** + **关键组件** + **调度策略与算法** 三个角度作答，结构清晰、重点突出，建议按照下面思路回答👇：

------

## ✅ 一句话总览（开头）

> “Pod 的调度流程是由 Scheduler 根据调度策略和资源情况，将 Pending 状态的 Pod 分配到合适的节点上执行的过程，调度结果最终由 Kubelet 在目标节点执行。”

------

## 🧭 Pod 调度流程（结构化讲法）

### 第一步：Pod 进入 `Pending` 阶段

- 当用户创建 Pod 后，Kube-API Server 接收请求并将其存入 `etcd`。
- 此时 Pod 没有 `nodeName`，状态为 `Pending`，等待调度器处理。

### 第二步：Scheduler 监听到新 Pod

- 调度器（kube-scheduler）监听未绑定节点的 Pod；
- 把该 Pod 放入调度队列，准备进行调度计算。

### 第三步：调度器执行调度逻辑（核心部分）

调度分为两个阶段：

#### ✅ 1. **预选（Filtering）阶段**：筛选可运行节点

- 过滤掉资源不足、污点冲突、亲和性不匹配等节点；
- 使用一系列插件（Predicate plugins），如：
  - `NodeUnschedulable`（不可调度节点过滤）
  - `PodFitsResources`（资源充足）
  - `TaintToleration`（污点容忍）

#### ✅ 2. **优选（Scoring）阶段**：对候选节点打分

- 比较资源利用率、拓扑分布、负载均衡等；
- 选择分数最高的节点；
- 插件如：
  - `LeastRequestedPriority`（资源利用最少优先）
  - `TopologySpreadConstraints`（跨 AZ 分布）

### 第四步：绑定 Pod 到节点

- 调度器通过 `Bind` API 调用将 `nodeName` 写入 Pod；
- Pod 状态从 `Pending` → `Scheduled`；
- 这一操作更新 etcd 中的 Pod 对象。

### 第五步：Kubelet 接管执行

- 目标节点上的 kubelet 监听到新调度的 Pod；
- 拉取镜像、挂载卷、创建容器；
- 容器运行后，Pod 状态变为 `Running`。

------

## 🧠 面试可加分的延伸点（选讲）

### 🧩 支持的调度策略：

- **NodeSelector**：静态绑定标签
- **NodeAffinity**：软/硬绑定节点
- **PodAffinity / AntiAffinity**：Pod 亲和性
- **Taints and Tolerations**：污点与容忍控制

### 🔧 调度器可自定义：

- 支持调度框架（Scheduler Framework），允许自定义插件；
- 也可以运行多个调度器（通过设置 `schedulerName`）；

------

## 🧪 示例追踪调度流程的命令：

```bash
kubectl describe pod <pod-name>      # 查看调度是否完成，绑定节点是谁
kubectl get pod -o wide              # 快速看到在哪个节点
kubectl get events                   # 查看调度日志
```

------

## 🏁 总结式收尾（给面试官印象）

> “Pod 调度是从 Pending → Scheduled 的过程，由 Scheduler 筛选合适节点并绑定，最终由目标节点上的 Kubelet 完成实际运行，整个流程既依赖资源状态，也支持灵活的调度策略。”

------

需要我根据你自己的工作经验（如有多节点、污点场景、自定义 scheduler）来设计个面试回答模板，让你更有“实战感”吗？