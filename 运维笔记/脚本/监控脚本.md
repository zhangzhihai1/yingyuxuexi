# 1.java微服务

## 1.1微服务stw

脚本或jvm打印堆栈

第一个方案，脚本打印堆栈

```powershell
java -Xms512m -Xmx1024m \
  -XX:+UseG1GC \
  -Xlog:gc*:file=/var/log/GC/xxx_gc.log:time,uptime,level,tags:filecount=10,filesize=10M \
  -jar /opt/xxx/xxx.jar > /dev/null 2>&1 &  如果排查启动错误，就nohup.out
  
  
jdk8：-Xloggc:/path/to/gc.log -XX:+PrintGCDetails

JDK 8 < u20：默认是 ParallelGC，建议手动指定 G1GC；
JDK 11+：默认是 G1GC，不写也生效；
```

```powershell
#!/bin/bash

# === 配置项 ===
# gc日志数组：服务名=路径
declare -A gc_logs=(
  ["xxx"]="/var/log/GC/xxx_gc.log"
  ["yyy"]="/var/log/GC/yyy_gc.log"
)

# 钉钉Webhook地址（请换成你自己的）
DINGDING_WEBHOOK="https://oapi.dingtalk.com/robot/send?access_token=你的token"

# 上次触发时间存放路径
STATE_DIR="/tmp/fullgc_monitor_state"
mkdir -p "$STATE_DIR"

# 执行堆栈打印的函数
dump_heap() {
  local service=$1
  local pid=$(pgrep -f "${service}.jar" | head -n1)
  local timestamp=$(date "+%Y%m%d_%H%M%S")
  local dump_file="/tmp/${service}_heap_${timestamp}.hprof"

  if [[ -n "$pid" ]]; then
    jmap -dump:live,format=b,file="$dump_file" "$pid"
    echo "[$(date)] $service dump to $dump_file"
    
    # 删除多余的老文件，只保留最近 3 个
    ls -t /tmp/${service}_heap_*.hprof | tail -n +4 | xargs -r rm -f

    # 钉钉告警
    curl -s -X POST "$DINGDING_WEBHOOK" \
      -H 'Content-Type: application/json' \
      -d "{
        \"msgtype\": \"text\",
        \"text\": {
          \"content\": \"${service} 服务发生 Full GC，堆栈已打印至 $dump_file\"
        }
      }" > /dev/null
  fi
}

# 主循环逻辑
for service in "${!gc_logs[@]}"; do
  gc_log="${gc_logs[$service]}"

  # 检查 GC 日志文件存在
  [[ -f "$gc_log" ]] || continue

  # 检测过去 20 行中是否 Full GC 超过 10 次
  count=$(tail -n 20 "$gc_log" | grep -Ei "Full\s*GC" | wc -l)

  if (( count >= 10 )); then
    last_trigger_file="$STATE_DIR/${service}.last"

    now=$(date +%s)
    last=$(cat "$last_trigger_file" 2>/dev/null || echo 0)

    if (( now - last >= 60 )); then
      echo "$now" > "$last_trigger_file"
      dump_heap "$service"
    fi
  fi
done
```

第二个方案，jvm打印堆栈

```powershell
java -Xms512m -Xmx1024m \
  -XX:+UseG1GC \
  -Xlog:gc*:file=/var/log/GC/xxx_gc.log:time,uptime,level,tags:filecount=10,filesize=10M \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/tmp/xxx_dumps \
  -jar /opt/xxx/xxx.jar > /dev/null 2>&1 &
```

```powershell
#!/bin/bash

# === 配置项 ===
declare -A services=(
  ["xxx"]="/var/log/GC/xxx_gc.log"
  ["yyy"]="/var/log/GC/yyy_gc.log"
)

# Dump 文件基础目录（每个服务一个子目录）
DUMP_BASE="/tmp"
mkdir -p "$DUMP_BASE"

# 钉钉 Webhook 地址（换成你的）
DINGDING_WEBHOOK="https://oapi.dingtalk.com/robot/send?access_token=你的token"

# 每分钟频率控制状态路径
STATE_DIR="/tmp/fullgc_monitor_state"
mkdir -p "$STATE_DIR"

# 主逻辑
for service in "${!services[@]}"; do
  gc_log="${services[$service]}"
  dump_dir="${DUMP_BASE}/${service}_dumps"
  mkdir -p "$dump_dir"

  # full gc 判断
  fullgc_count=$(tail -n 20 "$gc_log" 2>/dev/null | grep -Ei "Full\s*GC" | wc -l)
  [[ "$fullgc_count" -lt 10 ]] && continue

  # 每分钟触发控制
  last_trigger_file="$STATE_DIR/${service}.last"
  now=$(date +%s)
  last=$(cat "$last_trigger_file" 2>/dev/null || echo 0)
  [[ $((now - last)) -lt 60 ]] && continue
  echo "$now" > "$last_trigger_file"

  # 查找最新 dump 文件（jvm 触发）
  newest_dump=$(ls -t "$dump_dir"/*.hprof 2>/dev/null | head -n1)

  # 如果找不到任何 dump 文件，跳过告警
  if [[ -z "$newest_dump" ]]; then
    echo "[$(date)] $service 未找到任何 dump 文件，跳过告警"
    continue
  fi

  # 清理多余的 dump 文件，保留最近 3 个
  ls -t "$dump_dir"/*.hprof 2>/dev/null | tail -n +4 | xargs -r rm -f

  # 钉钉告警
  curl -s -X POST "$DINGDING_WEBHOOK" \
    -H 'Content-Type: application/json' \
    -d "{
      \"msgtype\": \"text\",
      \"text\": {
        \"content\": \"${service} 服务发生 Full GC，堆栈已由 JVM 自动转储，文件位置：$newest_dump\"
      }
    }" > /dev/null

  echo "[$(date)] ${service} full gc 触发告警，最近 dump: $newest_dump"
done
```

改进

```powershell
1. 加入 GC 类型统计
配合 GC日志分析工具（如 GCViewer、GCEasy.io）离线分析，或者用 JFR + JMC 采样分析

2. 加一层实时线程状态排查（top、jstack） 
可以在 full gc 时同步生成：
# 记录线程快照
jstack <pid> > /tmp/${service}_jstack_$(date +%F_%H-%M-%S).log
ls -t /tmp/${service}_jstack_*.log | tail -n +4 | xargs -r rm -f

3. 同时记录系统负载
避免 GC 只是表象，真实问题可能是 I/O 或线程阻塞：
top -b -n 1 > /tmp/${service}_top_$(date +%F_%H-%M-%S).log
iostat -x 1 3 >> /tmp/${service}_top_$(date +%F_%H-%M-%S).log

4. 使用 JFR 替代 HeapDump（更轻量）【选做】
JDK 11+ 推荐使用
-XX:StartFlightRecording=filename=/tmp/xxx.jfr,duration=60s,settings=profile

jstack 是 用于排查 Java 应用线程卡顿、死锁、CPU 飙高等运行时问题 的工具。它可以打印出当前 Java 进程中所有线程的调用栈（Thread Stack Trace）
```

